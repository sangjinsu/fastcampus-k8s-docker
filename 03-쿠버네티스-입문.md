# Part3. 쿠버네티스 입문

## 쿠버네티스가 왜 필요한가?

- 수많은 마이크로서비스를 여러 서버에 효율적으로 배치하는 것은 어렵다
- 마이크로서비스별 리소스 사용량 예측
- 정해진 EC2 인스턴스에 정해진 마이크로서비스 컨테이너를 배포 및 실행
- 하지만 여러 서버와 마이크로서비스 배포 조합 수를 계산할 수 없으며 충분한 리소스를 할당하면 리소스 낭비 및 비용이 발생
- 간단한 재시작으로 해결되는 경우에도 복구 시간이 오래 걸림

## 쿠버네티스 제공 서비스

- 자동화된 빈 패킹
- 자동화된 복구
- 자동화된 롤아웃과 롤백

## 쿠버네티스 의미

- 쿠버네티스는 여러 개의 컨테이너화된 애플리케싱션을 여러 서버(쿠버네티스 클러스터)에 자동으로 배포 및 스케일링, 관리해주는 오픈소스 시스템

## 쿠버네티스 클러스터

- 클러스터
- 여러 개의 서버를 하나로 묶은 집합, 하나의 서버처럼 동작
- 쿠버네티스 클러스터
    - 애플리케이션 컨테이너를 배포하기 위한 서버 집합

### Master 노드의 Control Plane

- 클러스터 상태를 저장하고 관리
    - etcd(key-value data store)
- api server
    - 클러스터 상태 조회, 변경을 위한 API 인터페이스 제공
- Scheduler
- Controller Managers

### Worker 노드

- 컨테이너 실행을 담당
    - Kubelet, Container Runtime
    - kube-proxy

### 쿠버네티스에 애플리케이션 컨테이너를 배포한다는 의미

- 쿠버네티스 오브젝트 Manifest 파일을 작성해서 마스터 노드에 있는 API Server 에게 요청을 보내는 행위
    - Manifest 파일이란
        - 쿠버네티스 오브젝트를 생성하기 위한 필수 정보
        - 일을 시키기 위한 지시서

## 클러스터 오브젝트 개념

- 쿠버네티스로 애플리케이션을 배포하고 관리하기
- 사용자 의도
    - 어떤 애플리케이션을
    - 얼마나
    - 어디에
    - 어떤 방식으로 배포할 것인가
- 쿠버네티스 오브젝트
    - 오브젝트 종류에 따라 정의할 수 있는 속성이 달라짐
- 사용자가 어떻게 쿠버네티스 오브젝트를 정의하느냐에 따라 쿠버네티스 상태가 결정된다
- 쿠버네티스 오브젝트를 이용해 개발팀의 구조, 배포, 정책, 프로세스를 표현한다
- 쿠버테니스 클러스터를 이용해 애플리케이션을 배포하고 운영하기 위한 필요한 모든 쿠버네티스 리소스

### 쿠버네티스 오브젝트 목록

- 어떤 애플리케이션 : Pod
- 얼마나 : ReplicaSet
- 어디에 : Node, Namespace
- 어떤 방식으로 배포할 것인가? : Deployment
- 트래픽을 어떻게 로드밸런싱할 것인가 : Service, Endpoint

### 오브젝트 기본 정보와 spec, status 필드

- apiVersion : 오브젝트를 생성할 때 사용하는 API 버전
- kind : 생성하고자 하는 오브젝트 종류
- metadata : 오브젝트를 구분 지을 수 있는 정보
    - name, resourceVersion, labels, namesapce ...
- spec : 사용자가 원하는 오브젝트 상태
    - 선언할 수 있는 속성은 오브젝트 종류마다 다르다
- status : 오브젝트가 쿠버네티스 클러스터를 생성되면 쿠버네티스는 오브젝트 정보에 status 필드를 추가하고 현재 실행 중인 오브젝트의 상태 정보를 알려준다

### 기본 명령어

```shell
# 쿠버네티스 클러스터에서 사용할 수 있는 오브젝트 목록 조회
kubectl api-resources 

# 쿠버네티스 오브젝트의 설명과 1레벨 속성들의 설명
# apiVersion, kind, metadata, spec, status
kubectl explain pod
kubectl explain deployment

# 쿠버네티스 오브젝트 속성들의 구체적인 설명 (Json 경로)
# kubectl explain <type>.<fieldName>[.<fieldName>]
kubectl explain pods.spec.containers

# 쿠버네티스 클러스터에서 속한 노드 목록 조회
kubectl get nodes

# 쿠버네티스 오브젝트 생성/변경
kubectl apply -f 01_06_deployment.yaml

# 실행 중인 Pod(컨테이너) 목록 조회 
kubectl get pods

# 애플리케이션 배포 개수를 조정 (replicas: 복제본)
kubectl scale -f deployment.yaml --replicas=3

# 현재 실행 중인 오브젝트 설정과 입력한 파일의 차이점 분석
kubectl diff -f deployment.yaml

# 쿠버네티스 오브젝트의 spec을 editor로 편집 (replicas를 4로 변경)
kubectl edit deployment/nginx-deployment: 

# 로컬 포트는 파드에서 실행 중인 컨테이너 포트로 포워딩
kubectl port-forward pod/nginx-deployment-74bfc88f4d-fkfjc 8080:80

# 현재 실행중인 컨테이너 프로세스에 접속하여 로그 확인
kubectl attach deployment/nginx-deployment -c nginx

# 현재 실행중인 컨테이너 프로세스에 모든 로그 출력 (-f: watch 모드)
kubectl logs deployment/nginx-deployment -c nginx -f

```

## Ch.2 Pod과 친해지기

### Pod 개념과 특징 

- 노드에서 컨테이너를 실행하기 위한 가장 기본적인 배포 단위 
- 여러 노드에 1개 이상의 Pod을 분산/실행 가능
- Pod Replicas
- 특징
  - 쿠버네티스는 Pod 생성시 노드에서 유일한 IP 를 할당 
  - 서버 분리 효과 
  - Pod 내부 컨테이너 간에 localhost 통신 가능, 포트 충돌 주의
  - Pod 안에서 네트워크와 볼륨 등 자원을 공유 
- PodIP 특징 
  - 클러스터 안에서만 접근 가능
  - 클러스터 외부 트래픽을 바기 위해서는 Service 혹은 Ingress 오브젝트가 필요 
- Pod : Container = 1:1 인가?
  - 컨테이너들의 라이프사이클은 같은가?
    - Pod 라이프 사이클 = 컨테이너들의 라이프사이클
    - 컨테이너 1이 종료되었을 때 컨테이너 2 실행이 의미가 있는가 
  - 스케일링 요구사항이 같은가 
  - 인프라 활용도가 더 높아지는 방향으로


# Part3. 쿠버네티스 입문

## 쿼버네티스가 왜 필요한가?

- 수많은 마이크로서비스를 여러 서버에 효율적으로 배치하는 것은 어렵다
- 마이크로서비스별 리소스 사용량 예측
- 정해진 EC2 인스턴스에 정해진 마이크로서비스 컨테이너를 배포 및 실행
- 하지만 여러 서버와 마이크로서비스 배포 조합 수를 계산할 수 없으며 충분한 리소스를 할당하면 리소스 낭비 및 비용이 발생
- 간단한 재시작으로 해결되는 경우에도 복구 시간이 오래 걸림

## 쿠버네티스 제공 서비스

- 자동화된 빈 패킹
- 자동화된 복구
- 자동화된 롤아웃과 롤백

## 쿠버네티스 의미

- 쿠버네티스는 여러 개의 컨테이너화된 애플리케싱션을 여러 서버(쿠버네티스 클러스터)에 자동으로 배포 및 스케일링, 관리해주는 오픈소스 시스템

## 쿠버네티스 클러스터

- 클러스터
- 여러 개의 서버를 하나로 묶은 집합, 하나의 서버처럼 동작
- 쿠버네티스 클러스터
    - 애플리케이션 컨테이너를 배포하기 위한 서버 집합

### Master 노드의 Control Plane

- 클러스터 상태를 저장하고 관리
    - etcd(key-value data store)
- api server
    - 클러스터 상태 조회, 변경을 위한 API 인터페이스 제공
- Scheduler
- Controller Managers

### Worker 노드

- 컨테이너 실행을 담당
    - Kubelet, Container Runtime
    - kube-proxy

### 쿠버네티스에 애플리케이션 컨테이너를 배포한다는 의미

- 쿠버네티스 오브젝트 Manifest 파일을 작성해서 마스터 노드에 있는 API Server 에게 요청을 보내는 행위
    - Manifest 파일이란
        - 쿠버네티스 오브젝트를 생성하기 위한 필수 정보
        - 일을 시키기 위한 지시서

## 클러스터 오브젝트 개념

- 쿠버네티스로 애플리케이션을 배포하고 관리하기
- 사용자 의도
    - 어떤 애플리케이션을
    - 얼마나
    - 어디에
    - 어떤 방식으로 배포할 것인가
- 쿠버네티스 오브젝트
    - 오브젝트 종류에 따라 정의할 수 있는 속성이 달라짐
- 사용자가 어떻게 쿠버네티스 오브젝트를 정의하느냐에 따라 쿠버네티스 상태가 결정된다
- 쿠버네티스 오브젝트를 이용해 개발팀의 구조, 배포, 정책, 프로세스를 표현한다
- 쿠버테니스 클러스터를 이용해 애플리케이션을 배포하고 운영하기 위한 필요한 모든 쿠버네티스 리소스

### 쿠버네티스 오브젝트 목록

- 어떤 애플리케이션 : Pod
- 얼마나 : ReplicaSet
- 어디에 : Node, Namespace
- 어떤 방식으로 배포할 것인가? : Deployment
- 트래픽을 어떻게 로드밸런싱할 것인가 : Service, Endpoint

### 오브젝트 기본 정보와 spec, status 필드

- apiVersion : 오브젝트를 생성할 때 사용하는 API 버전
- kind : 생성하고자 하는 오브젝트 종류
- metadata : 오브젝트를 구분 지을 수 있는 정보
    - name, resourceVersion, labels, namesapce ...
- spec : 사용자가 원하는 오브젝트 상태
    - 선언할 수 있는 속성은 오브젝트 종류마다 다르다
- status : 오브젝트가 쿠버네티스 클러스터를 생성되면 쿠버네티스는 오브젝트 정보에 status 필드를 추가하고 현재 실행 중인 오브젝트의 상태 정보를 알려준다
